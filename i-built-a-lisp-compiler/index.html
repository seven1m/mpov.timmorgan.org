<!doctype html><html lang=en-us><head><title>I Built a Lisp Compiler | My Point of View</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="I&rsquo;m very proud to announce the completion of my first programming language compiler!
Malcc is an incremental and ahead-of-time lisp compiler written in C.
This is the story of my progress over the years and what I learned in the process. An alternate title for this post is: &ldquo;How to Write a Compiler in Ten Years or Less&rdquo;
(There&rsquo;s a TL;DR at the bottom if you don&rsquo;t care about the backstory."><meta name=generator content="Hugo 0.100.2"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.png type=image/x-icon><link rel=stylesheet type=text/css href=https://mpov.timmorgan.org/css/asciinema-player.css></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav><main class=main><section id=single><h1 class=title>I Built a Lisp Compiler</h1><div class=tip><time datetime="2019-03-26 21:10:09 -0500 -0500">Mar 26, 2019</time>
<span class=split>¬∑</span>
<span>1534 words</span>
<span class=split>¬∑</span>
<span>8 minute read</span></div><div class=content><p>I&rsquo;m very proud to announce the completion of my first programming language compiler!</p><p><strong><a href=https://github.com/seven1m/malcc target=_blank rel=noopener>Malcc</a> is an incremental and ahead-of-time lisp compiler written in C.</strong></p><div class=asciinema-player data-src=/casts/malcc.cast data-cols=80 data-rows=15 data-autoplay=yes data-preload=1 data-loop=yes data-start-at=0 data-speed=1></div><p>This is the story of my progress over the years and what I learned in the process. An alternate title for this post is:
&ldquo;How to Write a Compiler in Ten Years or Less&rdquo;</p><p>(There&rsquo;s a <a href=#mal-tldr>TL;DR</a> at the bottom if you don&rsquo;t care about the backstory.)</p><h2 id=successful-failures>Successful Failures <a href=#successful-failures class=anchor>üîó</a></h2><p>I have dreamed of writing a compiler for nearly a decade. I&rsquo;ve always been fascinated by how programming
languages work, especially compilers. Though, I imagined a compiler as dark magic and understanding how to
make one from scratch firmly out of reach for a mere mortal such as myself.</p><p>But that didn&rsquo;t stop me from doing and learning!</p><h3 id=first-an-interpreter>First, an Interpreter <a href=#first-an-interpreter class=anchor>üîó</a></h3><p>In 2011, I started work on a simple interpreter for a made-up language called &ldquo;Airball.&rdquo; You can tell from the name
how much confidence I had in myself to make it work. It was a fairly simple program written in Ruby that
parsed the code and walked the <a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree target=_blank rel=noopener>abstract syntax tree</a> (AST).
Once I realized it did kind of work, I renamed it <a href=https://github.com/seven1m/lydia target=_blank rel=noopener>Lydia</a> and rewrote it in C
to make it faster.</p><p><p class=markdown-image><img src=/images/lydia.png alt="Lydia programming language syntax"></p></p><p>I remember thinking the syntax for Lydia was quite clever! I do still enjoy the simplicity of it.</p><p>While Lydia was far from the compiler I wanted to make, it was a small taste that inspired me to keep going.
Though, I was still plagued by unanswered questions of how to make a compiler work: <em>What do I compile <em>to</em>?
Do I have to learn assembly language?</em></p><h3 id=second-a-bytecode-compiler-and-interpreter>Second, a Bytecode Compiler and Interpreter <a href=#second-a-bytecode-compiler-and-interpreter class=anchor>üîó</a></h3><p>As a next step, in 2014, I started work on my <a href=https://github.com/seven1m/scheme-vm target=_blank rel=noopener>scheme-vm</a>
&ndash; a <a href=https://en.wikipedia.org/wiki/Virtual_machine#Process_virtual_machines target=_blank rel=noopener>virtual machine</a> for Scheme written
in Ruby. I thought using a VM with its own stack and bytecode would be a nice middle-ground between an AST-walking
interpreter and a full compiler. And since Scheme is <a href=http://www.scheme-reports.org/ target=_blank rel=noopener>formally specified</a>, I wouldn&rsquo;t
have to invent anything.</p><p>I tinkered off-and-on with my scheme-vm for over three years and learned a lot about how to think about compiling.
But, in the end, I knew I couldn&rsquo;t finish it. The code was becoming an unmaintainable mess and I still had a long
way to go to completion. Without a guide or previous experience, I was mostly feeling my way around in the dark.
It turns out that a language <em>specification</em> is not the same as a <em>guide</em>. Lesson learned!</p><p>By the end of 2017, I had shelved scheme-vm in search of something better.</p><h2 id=enter-mal>Enter Mal <a href=#enter-mal class=anchor>üîó</a></h2><p><p class=markdown-image><img src=/images/stepA_mal.png alt="final step diagram from the Mal guide, courtesy Joel Martin"></p></p><p>Some time in 2018 I happened across <a href=https://github.com/kanaka/mal target=_blank rel=noopener>Mal</a>, the Clojure-inspired Lisp interpreter.</p><p>Mal was invented by Joel Martin as a learning tool and has since gathered over 75 implementations in
different host languages! I knew when I saw all those different implementations that I could learn a lot about
the process &ndash; if I got stuck, I could go consult the Ruby or Python implementation for cheats. Finally, someone
who speaks my language!</p><p>I also figured that if I could get through the steps writing an interpreter for Mal, I could probably repeat
those same steps to make a compiler for Mal.</p><h3 id=a-mal-interpreter-in-rust>A Mal Interpreter in Rust <a href=#a-mal-interpreter-in-rust class=anchor>üîó</a></h3><p>My first go was to follow the <a href=https://github.com/kanaka/mal/blob/master/process/guide.md target=_blank rel=noopener>step-by-step guide</a>
and build an interpreter. At the time, I was also heavy into learning <a href=https://www.rust-lang.org/ target=_blank rel=noopener>Rust</a>
(I&rsquo;ll save that for another blog post), so I created my own implementation of Mal in Rust:
<a href=https://github.com/seven1m/mal-rust target=_blank rel=noopener>mal-rust</a></p><p>I wrote a bit <a href=http://seven1m.sdf.org/experiments/make_a_lisp_in_rust.html target=_blank rel=noopener>about my time using Rust here</a>.</p><p><strong>This was an absolute joy!</strong> I cannot give enough praise or thanks to Joel for creating the excellent Mal guide.
It has <em>detailed</em> written steps, flowcharts, pseudocode, and <strong>tests</strong>! &ndash; everything a developer would need to
make a programming language from start to finish.</p><p>By the end of the Mal guide, I was running the Mal implementation of Mal (written in Mal) on top of my Rust-hosted
implementation of Mal. (2 levels deep, whew) I jumped on my chair in excitement when this worked the first time!</p><h3 id=a-mal-compiler-in-c>A Mal Compiler in C <a href=#a-mal-compiler-in-c class=anchor>üîó</a></h3><p>Once I proved mal-rust to be a viable Mal implementation, I started researching how I could write a compiler.
Do I compile to assembly? Do I dare compile directly to machine code?</p><p>I saw an x86 assembler written in Ruby which intrigued me, but the thought of working with assembly gave me pause.</p><p>At some point I happened across <a href="https://news.ycombinator.com/item?id=13250722" target=_blank rel=noopener>this comment on Hacker News</a>,
which mentioned using the <a href=https://bellard.org/tcc/ target=_blank rel=noopener>Tiny C Compiler</a> as a &ldquo;compilation backend.&rdquo; This seemed
like a great idea!</p><p>TinyCC has a test file showing <a href=https://github.com/TinyCC/tinycc/blob/mob/tests/libtcc_test.c target=_blank rel=noopener>how to use libtcc</a>
to compile a string of C code from a C program. This gave the start I needed to build a &ldquo;hello world&rdquo; proof of
concept.</p><p>Starting again with the Mal step-by-step guide, along with my stale C experience, I was able to build a Mal compiler
in a couple months worth of spare evenings and weekends. The process was a joy.</p><p><p class=markdown-image><img src=/images/mal-tests.png alt="mal test suite"></p></p><p>If you&rsquo;re used to test-driven development, you&rsquo;ll recognize how valuable having a pre-done test suite is. The tests
will guide you toward a working implementation.</p><p>I can&rsquo;t say much about this process, other than, again, <strong>the Mal guide is a treasure.</strong> At each step, I knew
exactly what what I needed to do!</p><h3 id=tricky-bits>Tricky Bits <a href=#tricky-bits class=anchor>üîó</a></h3><p>Thinking back, here are some tricky bits specific to writing a Mal compiler that I had to figure out:</p><ol><li><p>Macros must be compiled on-the-fly during compilation and ready to be executed during compilation of the program.
This is a little mind-bendy.</p></li><li><p>The &ldquo;environment&rdquo; (the tree of hashes/associative-arrays/dictionaries that holds variables and their values)
needs to be present for both the compiler code and the resulting code for the compiled program. This is so
that macros can be defined at compile time.</p></li><li><p>Since the environment is available at compile time, I originally had Malcc catching <em>undefined</em> errors
(access of a variable that was not defined) at compile time, but this broke expectations of the Mal test suite
in a couple places. In the end, I disabled that feature so I could get the test suite passing. It would be cool
to add it back as an optional compiler flag though, since it could catch a great deal of errors ahead-of-time.</p></li><li><p>I compiled the C code by writing to three strings passed around in a struct:</p><ul><li><code>top</code>: top level code &ndash; functions are written here</li><li><code>decl</code>: declarations &ndash; declaring and initializing variables used in the body</li><li><code>body</code>: where the main work is done</li></ul></li><li><p>I spent a day thinking about writing my own garbage collector, but decided it could be an exercise for further
learning at a later date. The <a href=http://www.hboehm.info/gc/ target=_blank rel=noopener>Boehm-Demers-Weiser Garbage Collector</a> is an easy
drop-in library and is readily available on lots of platforms.</p></li><li><p>It&rsquo;s critical to be able to easily see the code your compiler is writing. Anytime my compiler saw the <code>DEBUG</code>
environment variable, it would spit out the compiled C code so I could review the mistakes.</p></li></ol><h3 id=things-id-do-differently>Things I&rsquo;d Do Differently <a href=#things-id-do-differently class=anchor>üîó</a></h3><ol><li><p>Writing C code and trying to keep it indented was a bit of a pain and I wish I would have done something else.
I believe some compilers write ugly code and then &ldquo;pretty it up&rdquo; with a library before writing it out. This
is something to explore!</p></li><li><p>Appending to strings when generating code is a bit messy. I might consider building an AST and then converting
that into the final string of C code. This should tidy up the code and give the compiler a nice bit of
symmetry too.</p></li></ol><p><a name=mal-tldr></a></p><h2 id=now-the-advice>Now the Advice <a href=#now-the-advice class=anchor>üîó</a></h2><p>I love that it&rsquo;s taken me nearly a decade to learn how to make a compiler. No, really. Each step along the
way is a fond memory in my process of becoming a better programmer.</p><p>That&rsquo;s not to say I&rsquo;m &ldquo;done&rdquo; though. There are still many hundreds of techniques and tools I need to learn
to feel like a real compiler writer. But I can confidently say &ldquo;I did it.&rdquo;</p><p><strong>Here is the process I&rsquo;d recommend to make your own Lisp compiler:</strong></p><ol><li>Pick a language you feel comfortable in. You don&rsquo;t want to be learning both a new language and how to make a
language at the same time.</li><li>Follow the <a href=https://github.com/kanaka/mal/blob/master/process/guide.md target=_blank rel=noopener>Mal guide</a> and write an interpreter.</li><li>Rejoice!</li><li>Follow the guide again, but instead of executing the code, write code that executes the code. (Don&rsquo;t just
&ldquo;refactor&rdquo; your existing interpreter though. Start from scratch. Copy and paste is fine.)</li></ol><p>I believe this technique can be used with just about any programming language that compiles to an executable.
For example, one could:</p><ol><li>Write a Mal interpreter in <a href=https://golang.org/ target=_blank rel=noopener>Go</a>.</li><li>Modify your Go code to:<ol><li>produce a string of Go code and write it to a file;</li><li>compile that resultant file with <code>go build</code> (by shelling out).</li></ol></li></ol><p>Ideally, there&rsquo;d be a way to control the Go compiler as a library rather than shelling out, but regardless,
this is one way to make a compiler!</p><p>With the Mal guide and your ingenuity, you can do it. If I can do it, so can you!</p><h2 id=thanks>Thanks <a href=#thanks class=anchor>üîó</a></h2><p>Many thanks to Joel Martin for creating Mal and giving it to the world!</p></div><div class=tags><a href=https://mpov.timmorgan.org/tags/lisp>lisp</a>
<a href=https://mpov.timmorgan.org/tags/c>c</a></div></section></main><footer id=footer><div class=copyright>¬© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span></div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer><script src=https://mpov.timmorgan.org/js/asciinema-player.min.js></script>
<script>document.querySelectorAll('.asciinema-player').forEach(e=>{const t={cols:e.dataset.cols,rows:e.dataset.rows,autoplay:!!e.dataset.autoplay,preload:!!e.dataset.preload,loop:!!e.dataset.loop,'start-at':e.dataset['start-at'],speed:e.dataset.speed,'time-limit':e.dataset['time-limit'],poster:e.dataset.poster,'font-size':e.dataset['font-size'],theme:e.dataset.theme,title:e.dataset.title,author:e.dataset.author,'author-url':e.dataset['author-url'],'author-img-url':e.dataset['author-img-url']};AsciinemaPlayer.create(e.dataset.src,e,t)})</script></body></html>